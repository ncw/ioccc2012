/************************************************************
mersenne.c - mersenne testing

FIXME this code was converted from the ARM prime project and needs a
lot of tidying up - getting rid of global variables etc.
************************************************************/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
/* #include<stdint.h> */
#include<inttypes.h>

/* defines */

#define u32 uint32_t
#define u64 uint64_t
#define VOID void
#define INT int
#define CALLOC_N calloc(n,sizeof(u64))
#define RETURN return
#define FOR for(
#define IF if(
#define SHR32 >>32
/* typedef uint32_t u32; */
/* typedef uint64_t u64; */
/* typedef uint32_t u32; FIXME combine two typedefs, or typedef plus definition?*/
/* typedef uint64_t u64; */

/* globals, initialised to 0 */

u64 //ROOT_ORDER=5<<26,		/* 5 * 2^26 */
//    MOD_P = 0xFFFFFFFF00000001,		/* p */
    MOD_P =  -(u64)(u32)-1,
//    ROOT_ONE = 0xED41D05B78D6E286,	/* the ROOT_ORDER-th root of 1 mod p */
//    ROOT_TWO = 0xC47FC73D33F80E14,	/* the ROOT_ORDER-th root of 2 mod p */
    *digit_weight,
    *digit_unweight,
    *x,
    MOD_W,
    MOD_INVW;

INT exponent,
    n,
    log_n,
    digit_width0,
    digit_width1,
    digit_width_0_max,
    /*uint8_t*/ *digit_widths;

/************************************************************
Modular arithmetic mod p = 2^64-2^32+1

Routines for arithmetic mod p = 2^64-2^32+1
-------------------------------------------

The special form of p means that we can make a mod p routine which only
involves a few shifts and arithmetic operations.  We use these facts

	2^64  == 2^32 -1 mod p
	2^96  == -1 mod p
	2^128 == -2^32 mod p
	2^192 == 1 mod p
	2^n * 2^(192-n) = 1 mod p

Also we use the fact that 2^64 - p is 2^32-1 ie 00000000FFFFFFFF so instead
of adding FFFFFFFF00000001 mod 2^64 we subract 00000000FFFFFFFF.  This is
convenient because the ARM carry flag is inverted for ADD and SUBtract so
it is best (conditional execution wise) to follow an ADD with an ADDCS and
a SUB with a SUBCC.  Read on and you will understand!

Note that some of the comments use positional notation where (a,b,c) is
2^64 * a + 2^32 * b + c
Note also that p = (2^32 -1, 1) in this notation

-----

Factors of p-1 are 2^32 * 3 * 5 * 17 * 257 * 65537
 
Note that a 64-th root of unity is 8 mod p.
 
This means that practically an FFT can be defined of length up to 2^32 with
optional factors of 3 and 5.
 
For the Discrete Weighted Transform we need an n-th root of 2.  2 has order
192 mod p (ie 2^192 mod p = 1) so we can have the
 
(p-1)/192 = (2^58 - 2^26) / 3 = 2^26 * 5 * 17 * 257 * 65537 th root of 2.
 
This means that we can do the DWT for lengths up to 2^26 with an optional
factor of 5
 
7 is a primitive root mod p

An n-th root of unity can be generated by 7^(5*(p-1)/n) mod p.
 
An n-th root of two can be generated by 7^(5*(p-1)/192/n) mod p
 
So a suitable 5 * 2^26-th root of 1 is 0xED41D05B78D6E286 and the 5 * 2^26-th
root of 2 is &C47FC73D33F80E14

-----

Many thanks to Peter-Lawrence Montgomery for working out the maths behind
how to do the 128 bit to 64 bit reduction mod p and the shifts mod p so
efficiently.  Peter also suggested the idea of using shifts in the
transform which really makes a lot of difference in execution speed on ARM

-----

We could shave a few cycles off here and there by using redundant
representation probably where the numbers are represented in the range
0..2^64-1.


Detecting carry on addition in C
--------------------------------

Using integers in range

0 <= x,y,z < N

A carry of x + y is if x + y >= N

However we calculate z = (x + y) % N

if (z < x)

There must have been a carry, but need there have been a carry?

=> (x + y) % N < x

0 <= x+y <= 2*N-2

if x+y < N:

  => (x + y) < x
  => false

if x+y >= N && x+y < 2N:

  => (x + y - N) < x
  => y - N < 0
  => y < N
  => true

Detecting carry on subtraction in C
-----------------------------------

This is much easier

Using integers in range

0 <= x,y,z < N

A carry of x - y is if x - y < 0

We can test for this directly and hope the compiler optimises it into
a test of the carry flag.

************************************************************/

/************************************************************
Define addition as x - (p - y).  This seemingly backwards way of doing
things works very well as it is much easier to make sure the result of a
subtraction is in the range 0..p-1 than an addition (the conditional
instructions for comparing > FFFFFFFF00000000 just don't work out

The addition sequence for x + y (mod p) works whenever
 
  0 <= x <= 2^64 - 1
  0 <= y <= p
  x + y <= 2p - 1
************************************************************/

u64 mod_add(u64 x, u64 y)
{
    x = MOD_P - x;	/* do addition by negating y then subracting */
			/* This can't overflow if y < p */
    /*
      what if y is 0, -y = p-0 which is out of range
      however subtracting y=p from x < p is guaranteed to carry which will fix it
      x = 0, y = 0, -y = p, x - -y = 0 - p = -p => carry, add p == 0 ok
      x = p-1, y = 0, -y = p, x - -y = p-1 - p = -1 => carry, add p == p-1 ok
    */

    u64 r = y - x;		/* y - (-x) */
    /* if borrow generated - hopefully the compiler will optimise this! */
    IF y < x)
	r += MOD_P;	/* Add back p if borrow */
    RETURN r;
}

/************************************************************
This adds a carry onto the number not using modulo arithmetic and
returns the carry of the first n bits
************************************************************/

u64 mod_adc(u64 x, u32 w, u64 *c)
{
// r0,r1 is x
// r2 is width
// r3 is pointer to carry
// r4,r5 is carry
// 
// mod_adc		FUNCTION
// 		STMFD	sp!, {r4-r6,lr}
// 
// 		LDR	r4, [r3, #0]	; carry
// 		LDR	r5, [r3, #4]
// 
// 		ADDS	r0, r0, r4	; sum = x + carry
// 		ADCS	r1, r1, r5      ; x + *carry
// 		MOVCC	r6, #0		; store carry for later
// 		MOVCS	r6, #1          ; overflow from addition

    u64 s = x + *c;
    /* carry?  See top for proof */
    u32 t =  s < x; /* ? 1 : 0; */

// 
// 		MOV	r4, r0, LSR r2  ; carry = (overflow*2**64 + sum) >> width
// 		RSB	lr, r2, #32	; make other shift
// 		ORR	r4, r4, r1, LSL lr
// 		MOV	r5, r1, LSR r2
// 		ORR	r5, r5, r6, LSL lr
// 
// 		STR	r4, [r3, #0]	; save carry
// 		STR	r5, [r3, #4]

    /* *carry = (carry_bit * 2**64 + sum) >> width */
    /* *carry = (sum >> width) + (carry_bit << 64) >> width */
    *c = (s >> w) + (t << (64-w));

// 		MOV	r0, r0, LSL lr	; mask off unused bits 
// 		MOV	r0, r0, LSR lr  ; result = sum & ((1 <<width)-1)
// 		MOV	r1, #0		; msw must be 0 (shift < 32)

    /* return low bits of the result */
    RETURN s & ((((u64)1) << w) - 1);

// 		LDMFD	sp!, {r4-r6,pc}^

}

/************************************************************
The subtraction sequence for x - y (mod p) works whenever
 
   0 <= x <= 2^64 - 1
   0 <= y <= 2^64 - 1
   -p <= x - y <= p - 1
************************************************************/

u64 mod_sub(u64 x, u64 y)
{

    u64 r = x - y;
    /* if borrow generated - hopefully the compiler will optimise this! */
    IF x < y)
	r += MOD_P;	/* Add back p if borrow */
    RETURN r;
}

/************************************************************
This reduces a 128 bit product mod p

  (x3,x2,x1,x0) mod p
  = (x2,x1,x0-x3)	[2^96 mod p = -1]
  = (x1+x2,x0-x3-x2)	[2^64 mod p = 2^32 -1]

Care is needed with the carries
************************************************************/

u64 mod_reduce(u64 b, u64 a)
{
    u32 d = b SHR32,
        c = b;
    IF a >= MOD_P)		/* (x1, x0) */
	a -= MOD_P;
    a = mod_sub(a, c);
    a = mod_sub(a, d);
    a = mod_add(a, ((u64)c)<<32);
    RETURN a;
}


/************************************************************
Mod Multiply

x,y must be in range 0..p-1
z will be in range 0..p-1
************************************************************/

u64 mod_mul(u64 x, u64 y)
{
    u32 a = x,
        b = x SHR32,
        c = y,
        d = y SHR32;

    /* first synthesize the product using 32*32 -> 64 bit multiplies */
    x = b * (u64)c; /* b*c */
    y = a * (u64)d; /* a*d */
    u64 e = a * (u64)c, /* a*c */
        f = b * (u64)d, /* b*d */
        t;

    x += y;			/* b*c + a*d */
    /* carry? */
    IF x < y)
	f += 1LL << 32; /* carry into upper 32 bits - can't overflow */

    t = x << 32;
    e += t;			/* a*c + LSW(b*c + a*d) */
    /* carry? */
    IF e < t)
	f += 1; /* carry into upper 64 bits - can't overflow*/
    t = x SHR32;
    f += t;			/* b*d + MSW(b*c + a*d) */
    /* can't overflow */

    /* now reduce: (b*d + MSW(b*c + a*d), a*c + LSW(b*c + a*d)) */
    RETURN mod_reduce(f, e);
}

/************************************************************
Calculate a ^ b mod p
Removed top bit speedup to save space
************************************************************/

u64 mod_pow(u64 a, u64 b)
{
    u64 r = 1;
    INT i;

    FOR i = 63; i >= 0; i--)
    {
        r = mod_mul(r, r);
        IF (b >> i) & 1)
            r = mod_mul(r, a);
    }

    RETURN r;
}

/************************************************************
Calculate 1/a mod p

We do this by the easy and not very efficient method below

    a^(p-1) = 1 mod p for any field element except 0
=>  a * a^(p-2) = 1 mod p
    therefore a^(p-2) mod p is 1/a
************************************************************/

u64 mod_inv(u64 a)
{
    RETURN mod_pow(a, MOD_P-2);
}

/************************************************************
; Multiply one array by another
;
;
; Entry
;	n = length
;	a -> array
;	b = multiplier array
; Exit
************************************************************/

VOID mod_vector_mul(u32 n, u64 *x, u64 *y)
{
    INT i;

    FOR i = 0; i < n; i++)
	x[i] = mod_mul(x[i], y[i]);
}

/************************************************************
; Square an array
;
;
; Entry
;	n = length
;	a -> array
;	b = multiplier array
; Exit
************************************************************/

VOID mod_sqr_vector(u32 n, u64 *x)
{
    INT i;
    FOR i = 0; i < n; i++)
	x[i] = mod_mul(x[i], x[i]);
}

/* ------------------------------------------------------------ */
/************************************************************
mod_fft.c - Modular FFT routines
************************************************************/

/************************************************************
A fastish O(n log n) FFT

Output is bit-reversed
************************************************************/

VOID fft_fastish()
{
    u64 d = MOD_W;
    INT k;

    FOR k = log_n; k >= 1; k--)
    {
        INT m = 1 << k,
            c = m >> 1,
            j,
            r;
        u64 w = 1;
        FOR j = 0; j < c; j++)
        {
            FOR r = 0; r < n; r += m)
            {
                INT a = r + j,
                    b = a + c;
                u64 u = x[a],
                    v = x[b];
                x[a] = mod_add(u, v);
                x[b] = mod_mul(mod_sub(u, v), w);
            }
            w = mod_mul(w, d);
        }
        d = mod_mul(d, d);
    }
}

/************************************************************
A fastish O(n log n) Inverse FFT

Input should be bit-reversed
************************************************************/

VOID invFft_fastish()
{
    INT k;

    FOR k = 1; k <= log_n; k++)
    {
        INT m = 1 << k,
            c = m >> 1,
            j,
            r;
        u64 z = (u64)(1<<((u32)log_n - (u32)k)),
            d = mod_pow(MOD_INVW, z),
            w = 1;
        FOR j = 0; j < c; j++)
        {
            FOR r = 0; r < n; r += m)
            {
                INT a = r + j,
                    b = a + c;
                u64 u = x[a],
                    v = mod_mul(w, x[b]);
                x[a] = mod_add(u, v);
                x[b] = mod_sub(u, v);
            }
            w = mod_mul(w, d);
        }
    }
}


/************************************************************
Try to do dwt...

n is size of transform
p is the exponent we want to test
i is the number of the element

    if (2*(pMersenne/FFTLEN) + LG2_FFTLEN >= 62*NPFFT) {
        fprintf(stderr, "FFTLEN = %s insufficient for pMersenne = %s\n",
                u64out(FFTLEN), u64out(pMersenne));
        exit(1);
    }

return 0 for failed 1 for ok
************************************************************/

INT mersenne_initialise()
{
    INT o = 0,
        i,
        w = exponent / n;

    /* calculate the n-th roots of one and two */

    /* calculate the n-th root of two */
    /* An n-th root of two can be generated by 7^(5*(p-1)/192/n) mod p */
    u64 s = mod_pow(7,(MOD_P-1)/192/n*5);

    /* An n-th root of unity can be generated by 7^(5*(p-1)/n) mod p. */
    //MOD_W = mod_pow(7,(MOD_P-1)/n*5);
    MOD_W = mod_pow(s,192);
    MOD_INVW = mod_inv(MOD_W);
    
    IF w >= 30)
        RETURN 0;
    
    digit_width0 = w;
    digit_width_0_max = 1 << w;
    digit_width1 = w + 1;
    
    /* memory allocation */
    x = CALLOC_N;
    digit_weight = CALLOC_N;
    digit_unweight = CALLOC_N;
    digit_widths = CALLOC_N;    /* This is oversized, but hey, ho... */

    /* digit weights */
    *digit_weight = 1;
    *digit_unweight = mod_inv(n);
    FOR i = 0; i <= n; i++)
    {
	u64 t = (u64)exponent * (u64)i,
            r = t % n,
            b = t / n; 
	u32 a;
        IF r SHR32)
            RETURN 0;
        IF (u32)r)        /* do ceil */
            b++;
        IF b SHR32)
            RETURN 0;
	a = b;

        /* bit position for digit[i] is ceil((exponent * i) / n) */
        IF i > 0)
        {
            digit_widths[i-1] = a - o;
            IF digit_widths[i-1] != w && (digit_widths[i-1] != w+1))
                RETURN 0;
            /* printf("digit_widths[%i] = %i from %i to %i\n", i-1, digit_widths[i-1], o, a-1); */
        }
        
        /* dwt weight is 2^(1 - ((exponent * i mod n)/n)) */
        IF i > 0 && i < n)
        {
            r = n - r;
            digit_weight[i]   = mod_pow(s, r);
            digit_unweight[i] = mod_inv(mod_mul(digit_weight[i], n));
        }
        
        o = a;
    }

/* fft_initialise */

    RETURN 1;
}

/************************************************************
Return the bottom 64 bits
Assumes a carry propagated array where all digits are within their widths
And that all digit widths are <= 32

If the residue is 0 then it checks the whole array to double check
that is zero for a proper primality check
************************************************************/

u64 mersenne_residue()
{
    INT i = 0,
        j = 0;
    u64 r = 0;
    FOR ; i < 64 && j < n; i += digit_widths[j], j++)
        r |= x[j] << i;
    IF r)
        RETURN r;
    FOR r = j = 0; j < n; j++)
        r |= x[j];
    RETURN r;
}

/************************************************************
This adds an u32 to x
We assume that x < 2^minimum_digit_width

It assumes that x has had the first round of carry propagation done on it
already so each digit[i] is < 2^digit_widths[i] < 2^32
************************************************************/

VOID mersenne_add32(u32 c, INT i)
{
    while (c)
    {
        FOR ; i < n; i++)
        {
            u32 y = 1 << digit_widths[i];
            x[i] += c;
            IF x[i] >= y)
                x[i] -= y,
                    c = 1;
            else
                RETURN;		/* done if no carry */
        }
/*         printf("Wrapping round the end in mersenne_add32\n"); */
        i = 0;
    }
}

/************************************************************
This subtracts an u32 from x
We assume that x < 2^minimum_digit_width

and that x has had the first round of carry propagation done on it
already so each digit[i] is < 2^digit_widths[i] < 2^32
************************************************************/

VOID mersenne_sub32(u32 c)
{
    INT i;
    while (c)
    {
        FOR i = 0; i < n; i++)
        {
            u32 y = 1 << digit_widths[i];
            x[i] -= c;
            IF x[i] >= y)
                x[i] += y,
                    c = 1;
            else
                RETURN;		/* done if no carry */
        }
/*         printf("Wrapping round the end in mersenne_sub32\n"); */
    }
}
    
/************************************************************
This adds an u64 to x

It assumes that x has had the first round of carry propagation done on it
already so each digit[i] is < 2^digit_widths[i] < 2^32
************************************************************/

VOID mersenne_add64(u64 c)
{
    INT i;
    while (c)
    {
        FOR i = 0; i < n; i++)
        {
            x[i] = mod_adc(x[i], digit_widths[i], &c);
            u32 t = c;
            IF !(c SHR32) && t < digit_width_0_max)
            {
                IF t)
                    mersenne_add32(t, i+1);	/* carry in 32 bits if possible */
                RETURN;				/* finished if carry is 0 */
            }
        }
        /* printf("Wrapping round the end in mersenne_add64\n"); */
    }
}
    
/************************************************************
This does one interation
************************************************************/

VOID mersenne_mul()
{
    INT i;
    u64 c = 0;

    /* weight the input */
    mod_vector_mul(n, x, digit_weight);
    
    /* transform */
    fft_fastish(log_n, x);

    /* point multiply */
    mod_sqr_vector(n, x);

    /* untransform */
    invFft_fastish(log_n, x);

    /* unweight and normalise the output */
    mod_vector_mul(n, x, digit_unweight);
    
    /* carry propagation */
    FOR i = 0; i < n; i++)
        // printf("x[%i]=0x%016llX, carry=0x%016llX\n", i, x[i], carry);
        x[i] = mod_adc(x[i], digit_widths[i], &c);
        // printf("x[%i]=0x%016llX, carry=0x%016llX\n", i, x[i], carry);
    IF c)
        // printf("Wrapping carry in mersenne_mul carry propagation\n");
        mersenne_add64(c);

    /* subtract 2 */
    mersenne_sub32(2);

}


/************************************************************
Usage:

prog q N [n]

where q = Mersenne exponent, N = fft run-length, n = Number of
Lucas iterations (or 0 for full test)
************************************************************/

INT main(INT w, char ** v)
{
    INT i,k,j;
//    if (w < 2 || w > 3)
    IF w < 2)
    {
//        printf("Usage:\n %s q [n]\nwhere q is exponent and n is iterations\n", v[0]);
//        printf("Usage:\n %s p [iters]\n", v[0])
        puts("Usage:@p@[n]");
        RETURN 1;
    }
    
    exponent = atoi(v[1]);
    j = w > 2 ? atoi(v[2]) : exponent - 2; /* iterations */
    /* initialise, finding correct fft size */
    /* FIXME causes memory leak */
    do log_n++, n = 1 << log_n;
    while(!mersenne_initialise());

    /* printf("Testing 2**%d-1 with fft size 2**%d for %d iterations\n", exponent, log_n, iterations); */

    FOR k = 0; k < 1; k++)
    {
        *x = 4;
        FOR i = 0; i < j; i++)
            mersenne_mul();
    }
    /* printf("0x%016llX\n", mersenne_residue()); */
    printf("0x%016" PRIX64 "\n", mersenne_residue());
    RETURN 0;
}
